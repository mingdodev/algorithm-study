<h1>2024-05-21</h1>
<strong>Theme 💭 </strong>
<small>백준 스터디 week 6</small>

<br/>

## 목차

1. [Dynamic Programming](#Dynamic-Programming)
2. [Backtracking의 시간 복잡도 분석](#Backtracking의-시간-복잡도-분석)

<br/>

## 정리

### Dynamic Programming

- 여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘
- DP[i]를 DP[i+1]로 알아낼 수 있다. 중간 결과를 저장하여 이용.
- 어떨 때 DP를 사용하는 지는 감으로 익히자..

- 푸는 순서
    1. 테이블 정의하기
    2. 점화식 찾기
    3. 초기값 정하기

<br>

**Ex. 25634 전구 뒤집기**

1. 테이블 정의하기
- DP1: (누르는 중) i번째를 누른 결과
- DP2: (한 번도 누르지 않은 상태에서) i번째를 누르지 않은 결과
- DP3: 이전에 누른 적이 있는가(연속적인가) 그 상태를 저장

2. 점화식 찾기
- DP1[i] = max(DP[i-1], DP2[i-1])
- DP2[i] = DP2[i-1]
- 이런 식으로..

3. i = 0일 때 문제 조건에 따라 만들 수 있겠지?

- 1차원 DP에서는, `상태를 분리`하여 테이블로 정의하는 것이 중요하다.

<br><br>

### Backtracking의 시간 복잡도 분석

- 은 고민해볼 필요가 있다. 정확히 알 수 없음
- 유망하지 않은 경우는 미리 생각하여 제거하자

    **Ex. 2661 좋은 수열 문제**
    - 나누기 2 하여 중복된 부분 있는지 판단할 때, 홀수일 경우 /2가 불가능  
    -> 첫 번째 수를 제거하여 나누자. 왜냐하면 어차피 첫 번째수가 포함된 수열이 나오지는 않음