<h1>2024-07-08</h1>
<strong>Theme 💭 </strong>
<small>시간복잡도</small>

<br/>

## 목차

1. [CPU의 연산 속도](#cpu의-연산-속도)
2. [시간 제한과 최대 입력 크기를 통해 시간복잡도 유추하기](#시간-제한과-최대-입력-크기를-통해-시간복잡도-유추하기)
3. [시간복잡도별 1초 최대 연산 횟수](#시간복잡도별-1초-최대-연산-횟수)
4. [다음 순열 알고리즘](#다음-순열-알고리즘)

<br/>

## 정리

### CPU의 연산 속도

- 일반적으로 1초에 1억번 연산

<br/>

### 시간 제한과 최대 입력 크기를 통해 시간복잡도 유추하기

>시간 제한이 1초  
> 1 <= N <= 10**5

라면 O(N**2)의 시간복잡도는 불가능
O(NlogN)까지는 가능

<br/>

### 시간복잡도별 1초 최대 연산 횟수

- O(N): 약 1억 번
- O(N**2): 약 1만 번
- O(N**3): 약 500 번
- O(2**N): 약 20 번
- O(N!): 10번

### 다음 순열 알고리즘

- 이름이 있는 알고리즘이었다
- 사람이 어떻게 문제를 해결하는지 단계를 생각해보고 규칙을 찾기(구채화)
- 첫 실마리는
    - 일의 자리 숫자가 십의 자리 숫자보다 클 때 문제가 가장 간단하다는 점이었다.
    - ex. 123 -> 132
    - 따라서 왼쪽으로 탐색할 때 값이 점점 증가하면 문제가 커진다.
    - 값이 작아지는 부분을 찾아야 한다. (그래야 교환했을 때 다음으로 큰 수가 등장한다.)

1) 오른쪽에서부터 왼쪽으로 탐색하며 오름차순인 부분 찾기
2) 감소하는 부분을 찾으면 거기가 기준점
3) 기준점 vs 오른쪽부터 탐색하는 수 -> 오른쪽에서 더 큰수를 발견하면 swap
4) **기준점 오른쪽을 오름차순 정렬하기**

- 4) 에서 생각이 막힌 게 오른쪽 값들로 생성할 수 있는 수들을 전부 비교한 뒤 작은 값을 찾아내야 한다고 생각했음. 그러면 시간복잡도가 줄어들 수가 없어서 말도 안 되는데 어떡하지라고 생각했다. 근데 생각해보니까 가장 작은 값은 오름차순 정렬한 수구나......

- JAVA로도 구현해보려 했으나 실력 부족임 일단 자바 공부를 할 것