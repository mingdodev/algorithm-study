<h1>2024-09-30</h1>
<strong>Theme 💭 </strong>
<small> 시간복잡도, 브루트포스, 백 트래킹 </small>

<br/>

## 목차

1. [시간복잡도](#기초-자료구조)
2. [브루트포스](#structclass)
3. [백트래킹](#정렬)
4. [각 자리수의 합 구하기](#각-자리수의-합-구하기)

<br/>

# 시간복잡도

- 입력값과 연산 수행 시간의 상관관계를 나타내는 척도
- 보통 1초에 1억 번 정도 연산하므로 시간복잡도를 통해 연산 수행 시간을 예측할 수 있다.

- 통상 점근 표기법을 사용하며, 기본적으로는 최악의 경우를 고려해야 함.
    - 최악의 경우가 흔치않아 테스트케이스에서 빠지는 경우(평균 고려할 때)도 있으나.. 거의 없음

## 주의할 점

- big-O/Omega/Theta는 함수의 상한/하한/평균을 나타냄
    - 평균 시간을 함수로 나타내고, 이 함수의 상한을 빅-오로 나타낸다는 것
- 대략적인 추이만 파악하자

## 점근 표기법

- 해당 식의 최고차항을 제외한 모든 항과 최고차항의 계수를 제외하기
    - N이 매우 커지는 경우를 고려하는 것, 즉 경향성을 판단한다.

- 로그가 등장하면 밑을 2로 보거나 신경쓰지 않는다.
    - 중요한 것은, 시간복잡도 수치가 상수`(O(1))`보다는 높고 선형`(O(N))`보다는 낮다는 것


<br>

---

# 브루트포스 (Bruteforce)

- 해가 나올 것 같은 모든 경우를 다 확인해보는 방법
- 가장 컴퓨터스러운 방법
- 무식한 힘

- 약수 구하기, 동전 뒤집기 등

- 다중 반복분 또는 재귀함수

<br>

---

# 백트래킹 (Backtracking)

- 브루트포스를 개선하는 알고리즘
    - 브루트포스는 시간이 오래 걸린다.

- 해를 찾아가는 도중에, 지금의 경로가 해가 될 것 같지 않으면 더 이상 가지 않고 되돌아가자.

- 가지치기(pruning)-> 불필요한 부분들을 쳐낸다.
- 유망하다(promising)-> 해가 될 가능성이 있다

- 장점
    - 잘하면 효율성이 고이장히 높아짐

- 단점
    - 최악의 경우에는 가지치기에 완전히 실패하여 브루트포스와 똑같은 성능을 낼 수도 있음
    - 여기서부터는 코드 문제가 아니라 로직이 잘못되는 경우가 생긴다.
    - 답이 될 수 없는 경우를 판별하기 어려워진다.

- 그리디와 반대 느낌
    - 그리디는 가능할 것 같은 걸 고르고, 백트래킹은 아닐 것 같은 걸 버린다.
    - 둘 다 판단이 중요한 문제


## 적용할 수 있는 문제

- 가지를 내칠 수 있는 문제, 어떤 것에 대해 `선택지`가 있는 문제
- **비선형적 탐색이 가능한 브루트포스 알고리즘**에 적용할 수 있다.
    - DFS, BFS, Best First Search

- 왜냐하면, 아니라면 바꿀 경로가 있어야하는데 선형적이라면 불가능함
- 즉 **선택지가 있거나 / 모든 경우의 탐색이 필요하지 않은 경우**

- Depth First Search, DFS
    - 구현: 재귀함수, 스택(스택오버플로 주의)

- Breadth First Search, BFS
    - 탐색 영역이 빠르게(지수적으로) 넓어질 수 있어 주의해야 함
    - 구현: 큐

### N-queen Problem

- 팁

    - 대각선 표현하기
    - 1차원 배열 사용하기
    - 메모리 최적화 + 시간 최적화 둘 다 가능!

<br>

---

# 각 자리수의 합 구하기

```java

    public static int sum(int n) {

        int t = n;
        int sum = 0;

        while(t != 0) {
            sum += t % 10;
            t /= 10;
        }

        return sum;
    }

```